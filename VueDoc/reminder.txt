CHƯƠNG 1: BẮT ĐẦU
- Vue dung lượng nhỏ => nhanh
- Có discord để hỏi bài: https://discord.com/channels/622033978047725582/633585681465344001
- new Vue (el, data, methods): control 1 element
- This: access hết trong data và methods
- Cấu trúc bài giảng
- Khai thác tài nguyên, bài tập ở đâu, có bao nhiều bài tập
- Cài đặt offline vuejs

CHƯƠNG 2: GIAO TIẾP VỚI DOM
- template vuejs hoạt động: copy dom đã được đánh dấu xuống thành 1 vue instance, biến đổi instance đó, đẩy lên lại dom
- template syntax và vue instance: ta không cần .this .data để trên template để truy cập vào vue instance khi muốn truy cập vào data hay methods.
- Truy cập vào dữ liệu của chính instance: khi methods cần dữ liệu từ data, chỉ cần call this.dữ liệu.
- v-bind:href="link" : (:) dùng để truyền giá trị từ vue instance vào 1 attribute. Chỉ cần truyền bình thường như truyền vào text: {{ link }}
- directive: chỉ thị cho 1 attribute
- <v-once> Khi một {{}} hay 1 v-bind bị render nhiều hơn 1 lần, nếu ta muốn ngăn chặn việc render nhiều hơn 1 lần, sử dụng v-once
- v-html="finishedLink": output raw html như một attribute qua 1 div hoặc p
- Link download tất cả các code và bài tập
- Bài tập 1
- v-on:click="increase": ngược với v-bind, v-on (@) lấy thông tin event từ element sau đó gán/sửa/thay đổi dữ liệu bên trong data, methods,..
- v-on:mouseover="changeCoordinate> {{x}} / {{y}}: sử dụng được thông qua biến event được truyền tự động qua mỗi method trong methods
- v-on:click="increase(2, $event)": truyền đối số vào hàm sử dụng dấu ngoặc đơn, nếu cần sử dụng biến event thì phải khai báo có dấu $ để vue ngầm hiểu
- v-on:mousemove.stop: .stop được gọi là event modifier, nó điều chỉnh sự kiện đứng trước một directive. phổ biến là stop(stop propagation) và prevent(default)
- @keyup.enter="alertMe": key modifier, tức là khi thực hiện sự kiện phía trước dấu . bằng phím được chain sau dấu chấm, sẽ trigger function phía sau
- Với các trường được control bởi vue như {{  }}, function phía sau v-on, ở đó có thể viết được một số code js đơn giản (k if, k loop, 1 biến, binary if). 
    => tăng sự liên kết của html và js 
- v-model="name": ràng buộc 2 chiều với data là name. Với element đặt ràng buộc 2
    chiều với name, nó sẽ vừa thực hiện việc của {{ }} là hiển thị name lên element,
    vừa thay đổi name khi thay đổi giá trị bên trong nó. Như một hậu quả, các 
    element khác bị binding bởi name cũng sẽ thay đổi giá trị.
- COMPUTED VS METHODS:
    + Methods rerun mỗi khi DOM mà nó quản lý có sự thay đổi 
        (vì nó phải kiểm tra xem những biến bên trong nó có bị thay đổi không)
        => không cần dấu () khi ở trong {{}}, tức là sử dụng như biến data
    + Computed không rerun mỗi khi DOM thay đổi. 
        Nó chỉ run khi những thuộc tính có bên trong nó có sự thay đổi
        => cần có dấu () khi ở trong {{}}
- {{ me() }}methods cần phải có dấu () khi ở bên trong {{}}. Khi được chỉ định ở
    v-on thì không cần phải có dấu (), mặc dù có cũng k sao
- watch: { counter: function(value){async code} }: watch là 1 property của Vue 
    dùng để thực hiện những tác vụ async KHI VÀ CHỈ KHI biến bên trong data được
    chỉ định (counter) bị thay đổi
- Bài tập: watch có thể theo dõi được cả Computed, do Computed được treat như 1 
    biến data 
- @click:"attachRed = !attachRed", :class="{red:attachRed}": dynamic styling các 
    class css của element: :class="{key: true/false}". Ý nghĩa: khi click vào 
    khu vực được control, directive @click sẽ thay đổi giá trị của biến attachRed 
    từ false -> true và ngược lại, từ đó directive :class sẽ lấy giá trị đó 
    mà gán vào key để thể hiện key này có được thêsm vào class hay không. 
    :class="{key:true/false}" là syntax của binding cho class
- Thay đổi linh động code class binding: đưa từ code html ở trên xuống code Computed
    js ở dưới
- Một cách khách để dynamic styling các class css của element là sử dụng 
    v-model="color" và cú pháp trực tiếp :class="color" để lấy giá trị từ v-model
    và gán thẳng vào :class
- Thay vì dynamic styling các class, ta có thể styling chính style của element,
    có cùng 1 cách để làm (v-model) :style="{backgroundColor: color}", v-model:...
    Chú ý là tên key bên trong object phải là camel case, hoặc nằm trong dấu ''.
- Cả 2 styling style và class đều có thể sử dụng phương pháp styling nâng cao là
    with array syntax: :style="[myStyle, {height: width + 'px'}]
=> đã học được gì? syntax Vue instance, template {{}}, directive, event modifier, 
    Computed vs method, dynamic styling class/style, 

CHƯƠNG 3: CÂU ĐIỀU KIỆN VÀ DANH SÁCH
- v-if="true/false": attach/detach element và các element con bên trong nó. Có thể sử 
    dụng v-else ngay bên dưới nó mà không cần khai báo gì khác, vue vẫn hiểu.
- Có cả v-else-if.
- vì v-if chỉ có tác dụng trên 1 element và con, ta có thể wrap các element đồng
    cấp vào trong 1 tag html là template. Template không xuất hiện trên dom như
    div hay p.
- v-show="true/false" có hiệu ứng hình ảnh tương tự như v-if, nhưng nó k gỡ bỏ 
    element trong dom, mà chỉ đơn giản display none element. V-show không hỗ trợ
    tag template
- <li v-for="i in array"> {{ i }}</li> được sử dụng như vòng lặp for, biến i có thể
    được truy xuất tại bất cứ đâu, như biến trong data.
- li v-for="(ins, i) in ingredients"> {{ ins }} ({{ i }}) </li>: ta có thể truy xuất
    chỉ số của ins trong mảng bằng cách thêm vào v-for 1 param thứ 2. Thứ tự xuất 
    hiện quan trọng.
- <template v-for="(ins, i) in ingredients"> sử dụng template v-for để sử dụng loop
    bên trong các tag không lồng nhau như <h1></h1> rồi <p></p>, tức là ins 1 chỗ
    i 1 chỗ
- <span v-for="(value, key) in name">{{key}} - {{value}}, </span> tương tự như loop
    through array, v-for còn có thể loop qua object như hình, với sự khác biệt khi
    đặt param bên trong là thứ tự của các param: (value, key, index);
- Ta cũng có thể đặt v-for bên trong 1 v-for khác để lặp một object array.
- <span v-for="i in 10"> {{ i }} </span>: nếu chỉ cần lặp 1 vòng lặp for đơn giản
    từ 1 - 10, ta sử dụng cú pháp trên
- <li v-for="(ins, i) in ingredients" :key="ins"> Khi ta thay đổi nội dung nội dung
    của 1 phần tử trong array lẫn thứ tự các phần tử của array đó, ta nên sử dụng
    :key="ins", ins phải là unique trong cả file
=> Đã học gì? v-if, v-show, v-for

CHƯƠNG 4: PROJECT ĐẦU
CHƯƠNG 5: VUE INSTANCE
- Có thể có nhiều vue instance
- vm1.title: Có thể truy cập vue instance từ bên ngoài code bt hoặc 1 instance khác.
- vm1.newProp = 'New!': Sự quan trọng của việc lưu giữ giá trị bên trong vue instance 
    và sự khác biệt khi add property bên ngoài instance. 
- ta có thể tạo 1 data value bên ngoài và gán nó vào 1 data property bên trong.
    Hoàn toàn hợp lệ. 
- this.$ref.'tên gán'.innerText / vm1.$ref.'tên gán'.innerText: là thứ ta có thể 
    truy cập vào nội dụng của một tag đã được gán thẻ ref.
- https://vi.vuejs.org/v2/api/: api
- vm1.$mount('#app1') = new Vue({el: '#app1'}), chỉ khác là trong và ngoài
- Một cách khác để giải thích cách vue instance hoạt động: vm3.$mount();
    document.getElementById('app3').appendChild(vm3.$el);
- Component đơn giản là một cách để tạo template và dùng nó ở nhiều nơi, khác với
    vue instance là chỉ có thể control 1 element
- Hạn chế vl khi dùng template, dù là el template hay tag template.
- VueJS update dom ntn: Nó copy 2 lần dom template đang control. template (1) dùng 
    để chỉnh sửa mọi thứ mà người dùng là, template 2 (virtual DOM) dùng để so sánh
    với template (1): cái nào đã được chỉnh sửa. Ghi nhận các chỉnh sử đó và đưa lên
    dom thật, chứ không phải render hết các dom chỉnh sửa và dom không đụng đến
- Vòng đời của VueJS instance: new Vue -> beforeCreated() -> created() -> 
    beforeMount() -> mounted() -> (1) beforeUpdate() -> updated() <=> / (2)
    beforeDestroy() -> destroyed().
    Giải thích: với các hàm này, ta có thể thêm code vào các giai đoạn khi Vue thực
    thi. CÁC HÀM NÀY CHƯA ĐƯỢC ĐỊNH NGHĨA @@.
        1. Khởi tạo vòng đời, sự kiện -> beforeCreated()
        2. Khởi tạo data và event (methods, computed), tạo ra instance -> created()
        3. Tìm el/template -> Biên dịch template đã có / Biên dịch outerHTML của el 
            (gán giá trị của data vào instance, thêm directive) -> beforeMount()
        4. Tạo vm.$el (?) và thay thế cho el -> mounted()
        5. Thay thế instance lên dom -> beforeUpdate()
        6. (điều kiện dom phải thay đổi) Virtual Dom và render lại -> updated()
        7. (điều kiện vm.destroy() được gọi) -> beforeDestroy()
        8. Tháo dỡ các watcher, eventListener, code,... -> destroyed().
CHƯƠNG 6: DEVELOPMENT WORKFLOW
- Development server @@@@@@@
- npm install -g @vue/cli -> vue  create test
- Cấu trúc của 1 vue project, 
CHƯƠNG 7: COMPONENT 
-  Vue.component('test', {}) với {} giống với new Vue({}) vì component là 1 thể hiện
    của vue instance =)). QUAN TRỌNG: data phải là 1 function trả về 1 object, chứ k phải là 1 
    object
- Mỗi component đều tạo ra một vùng kiểm soát riêng, với data, template và methods 
    riêng. Nếu ta sử dụng chung 1 trong số các loại trên, có thể sẽ xảy ra lỗi.
- Điều tương tự sẽ xảy ra với component. Ta không nên register 1 component globally
    bằng cách Vue.component. Thay vào đó, ta lưu nó như một object:
    components: { 'test': cmp }
- QUAN TRỌNG: các nội dung bên trong component phải được bọc bên trong 1 div, nếu
    không sẽ không chạy
- cách đặt tên component: camel case
- Giới hạn style trong 1 component: sử dụng <style scoped> ... </style>. Scoped này sẽ
    add các style lên trên header, cùng với một style id riêng biệt cho mỗi component.

CHƯƠNG 8: GIAO TIẾP GIỮA CÁC COMPONENT
- Truyền dữ liệu từ C cha đến C con: sử dụng props
    1. C cha tạo ra data function, các methods liên quan.
    2. Trên template, C cha truyền data cần truyền thành value của 1 :st
    3. Ở C con, trong script phải khai báo data đã nhận thông qua template bằng props
    4. Khai báo lên template con bằng {{ st }}.
    Nên đặt tên không viết hoa cho các data và tên attribute được truyền
- biến nằm trong props có thể sử dụng như 1 data bình thường, tức là có thể gọi bằng this
- Để đảm bảo giá trị props nhận được, ta nên validate nó tại props: 
    ten: { type: String, default: 'aaax'/required: true}
- Truyền dữ liệu từ C con lên C cha:'
    1. this.$emit('nameWasReset', this.ten) (đặt nó bên trong 1 methods)
    2. @nameWasReset="name = $event" (name là biến data được tạo sẵn, $event là giá trị passed)
- Thay vì sử dụng emit và event để đưa dữ liệu lên C cha, ta có thể tạo callback ở C cha và truyền callback đó thông qua props xuống C con
    để thực thi.
- Truyền dữ liệu giữa 2 C con với nhau: có 3 cách
    1. $emit and $event
    2. callback in C cha
    3. eventBus: Tạo biến để lưu dữ liệu trao đổi ở cả 2 C -> tạo một vue instance mới ở file khác -> import vue instance đó vào 2 C (eventBus)
        -> sử dụng eventBus.$emit('ten', giaTri) để đưa lên eventBus. Thay vì emit thì ta có thể tạo 1 function trên Vue mới và gọi ở đây
        -> ở C nghe, tạo created(){ eventBus.$on((data) => {this.userAge = data} )}